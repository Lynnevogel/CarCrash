Hill Climber: geef x aantal random oplossingen aan Hill Climber, voeg deze oplossingen bij elkaar
en gebruik vervolgens breadth first om de beste oplossing te vinden. Hierbij verklein je dus je statespace 
enorm, omdat je niet meer alle mogelijke moves doorzoekt, maar alleen de moves die gegenereert zijn door 
de random oplossingen. 

- input hill climber: lijst met x aantal oplossingen
    - waarbij oplossingen een lijst van borden zijn
    - gebruik in Board class use_solution om die lijst met borden te genereren
    - voeg die oplossingen aan elkaar toe zodat je een enorme lijst krijgt van alle mogelijke states
    - die enorme lijst in de __init__
- hill climber gaat vervolgens een nieuwe betere oplossing te vinden door gebruik te maken van de 
mogelijke states
- dus bij begint weer bij het start bord, en gaat vervolgens kijken wat de mogelijke moves zijn in die lijst
- oftewel, hij gaat breadth first search doen, maar met een beperkt aantal moves

maak queue aan
while queue is not empty:
    new_state = queue.get_next_state
    for car in all_cars_on_board:
        get possible moves for car
        add possible moves to queue
        if game is won:
            break???
            


    kijk in lijst met alle borden wat mogelijke moves zijn. damn dat is ingewikkeld
get possible moves for car:
get car
zoek borden waar alle cars op dezelfde plek staan behalve huidige car
zet dat bord in states

zoek borden waar alle cars op dezelfde plek staan behalve huidige car:
